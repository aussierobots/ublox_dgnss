#!/usr/bin/env python3
# Copyright (c) 2025 Australian Robotics Supplies & Technology
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Generate TOML configuration files from existing ubx_cfg_item_map.hpp
"""

import re
from pathlib import Path


def extract_params_with_family_rules(hpp_file):
    """Extract parameters with their inclusion/exclusion rules"""
    with open(hpp_file) as f:
        lines = f.readlines()

    params_with_rules = {}  # param_name -> {'only': set(), 'exclude': set()}
    current_rule = None

    for line in lines:
        stripped = line.strip()

        # Parse @only annotation (whitelist specific families)
        if stripped.startswith('// @only:'):
            only_str = stripped.replace('// @only:', '').strip()
            only_families = set(f.strip() for f in only_str.split(','))
            current_rule = {'type': 'only', 'families': only_families}
            continue

        # Parse @exclude annotation (blacklist specific families)
        if stripped.startswith('// @exclude:'):
            exclude_str = stripped.replace('// @exclude:', '').strip()
            exclude_families = set(f.strip() for f in exclude_str.split(','))
            current_rule = {'type': 'exclude', 'families': exclude_families}
            continue

        # Reset on blank lines or non-annotation comments
        if stripped == '' or (stripped.startswith('//') and '@' not in stripped):
            current_rule = None
            continue

        # Match parameter definition
        match = re.search(r'const ubx_cfg_item_t\s+(\w+)\s*=', line)
        if match:
            param_name = match.group(1)
            params_with_rules[param_name] = current_rule
            # DON'T reset - let annotation persist until explicitly cleared

    return params_with_rules

def should_include_param(param_rule, target_family):
    """Determine if parameter should be included for target family"""
    if param_rule is None:
        # No annotation = include in all families
        return True

    if param_rule['type'] == 'only':
        # @only: only include if target is in the list
        return target_family in param_rule['families']

    if param_rule['type'] == 'exclude':
        # @exclude: include unless target is in the exclusion list
        return target_family not in param_rule['families']

    return True

def filter_params_for_family(params_with_rules, target_family):
    """Get parameters for a specific device family"""
    return sorted([name for name, rule in params_with_rules.items()
                    if should_include_param(rule, target_family)])


def write_toml(params, path, family, desc):
    """Write TOML configuration file"""
    with open(path, 'w') as f:
        f.write(f'# {family} UBX Configuration\n')
        f.write(f'# {desc}\n')
        f.write(f'# Filters existing ubx_cfg_item_map.hpp (NO changes to static map)\n')
        f.write(f'# Generated by generate_toml_from_existing.py\n\n')

        f.write(f'[metadata]\n')
        f.write(f'device_family = "{family}"\n')
        f.write(f'description = "{desc}"\n')
        f.write(f'version = "1.0"\n')
        f.write(f'parameter_count = {len(params)}\n\n')

        f.write(f'[parameters]\n')
        f.write(f'include = [\n')
        for p in params:
            f.write(f'    "{p}",\n')
        f.write(f']\n')

    print(f"Generated {path} with {len(params)} parameters")


def main():
    # Get script directory
    script_dir = Path(__file__).parent

    # Paths relative to script location (script is in ublox_dgnss/scripts/)
    hpp_file = script_dir / '../../ublox_dgnss_node/include/ublox_dgnss_node/ubx/ubx_cfg_item_map.hpp'
    config_dir = script_dir / '../config'

    # Create config directory if it doesn't exist
    config_dir.mkdir(parents=True, exist_ok=True)

    # Extract all parameters with family rules
    params_with_rules = extract_params_with_family_rules(hpp_file)

    # F9P: parameters
    f9p_params = filter_params_for_family(params_with_rules, 'F9P')
    write_toml(
        f9p_params,
        config_dir / 'f9p_ubx_config.toml',
        'F9P',
        'ZED-F9P baseline configuration'
    )

    # F9R: parameters
    f9r_params = filter_params_for_family(params_with_rules, 'F9R')
    write_toml(
        f9r_params,
        config_dir / 'f9r_ubx_config.toml',
        'F9R',
        'ZED-F9R with sensor fusion'
    )

    # X20P: parameters
    x20p_params = filter_params_for_family(params_with_rules, 'X20P')
    write_toml(
        x20p_params,
        config_dir / 'x20p_ubx_config.toml',
        'X20P',
        'ZED-X20P full configuration'
    )

    # Summary
    print(f'\n=== Summary ===')
    print(f'Total parameters in map: {len(params_with_rules)}')
    print(f'F9P parameters: {len(f9p_params)}')
    print(f'F9R parameters: {len(f9r_params)} (+{len(f9r_params)-len(f9p_params)} vs F9P)')
    print(f'X20P parameters: {len(x20p_params)} (+{len(x20p_params)-len(f9p_params)} vs F9P)')

if __name__ == '__main__':
    main()